#version 330
layout(location = 0) in int NESColor;
layout(location = 1) in vec4 PixelShape;

uniform mat4 PMatrix;
uniform mat3 YIQMatrix;

const mat3 NonFCCYIQMatrix = mat3(
	vec3(1,1,1),
	vec3(0.9563, -0.2721, -1.1070),
	vec3(0.6210, -0.6474, 1.7046)
);


uniform int Scanline;
uniform int PPUPhase;

uniform float Gamma = 2;
uniform float Saturation = 1.2;
uniform float Brightness = 1.0;

flat out vec3 PixelColor;

vec3 YIQtoRGB(in vec3 YIQ)
{
	return transpose(NonFCCYIQMatrix) * YIQ;
}

const float atten = 0.746f;
const float levels[8] = float[](
	0.350f, 0.518f, 0.962f, 1.550f,
	1.094f, 1.506f, 1.962f,  1.962f
);


vec3 NEStoRGB(in int pixel)
{
	int color = pixel & 0x0F;
	int level = (pixel >> 4) & 0x03;
	int emp = (pixel >> 6);
	
	if(color > 13)
		level = 1;
	
	float low = levels[0 + level];
	float high = levels[4 + level];
	
	if(color == 0)
		low = high;
	else if(color > 12)
		high = low;
		
	vec3 yiq = vec3(0);

	int genPhase = PPUPhase + gl_InstanceID * 8;
	float decodingPhase = genPhase + 3.9f;

	for(int i = 0; i < 12; i++)
	{
		float signal = (((color + genPhase + i) % 12) < 6) ? high : low;
		signal = (signal - levels[1]) / (levels[7] - levels[1]);
				
		float value = signal * Brightness / 12f;
		yiq.r += value;
		value *= Saturation;
		yiq.g += value * cos((3.141592653/6) * (decodingPhase +i ) /12f);
		yiq.b += value * sin((3.141592653/6) * (decodingPhase + i) / 12f);
	}
	
	
	vec3 rgb = YIQtoRGB(yiq);
	return min(vec3(255f), vec3(255.95f) * pow(max(vec3(0), rgb), vec3(2.2 / Gamma))) / vec3(255f);
}

void main()
{
	vec4 pos = PixelShape + vec4(gl_InstanceID, Scanline, 0, 0);
	gl_Position = PMatrix * pos;
	PixelColor = NEStoRGB(NESColor);
}