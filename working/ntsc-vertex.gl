#version 330
layout(location = 0) in ivec2 NESColor;
layout(location = 1) in vec4 PixelShape;

uniform mat4 PMatrix;
uniform mat3 YIQMatrix;

const mat3 NonFCCYIQMatrix = mat3(
	vec3(1,1,1),
	vec3(0.9563, -0.2721, -1.1070),
	vec3(0.6210, -0.6474, 1.7046)
);


uniform int Scanline;
uniform float PPUPhase;

uniform float Gamma = 2;
uniform float Saturation = 1.7;
uniform float Brightness = 1.0;

flat out vec3 PixelColor;

vec3 YIQtoRGB(in vec3 YIQ)
{
	return transpose(NonFCCYIQMatrix) * YIQ;
}

const float black = 0.518f;
const float white = 1.962f;
const float atten = 0.746f;
const float levels[8] = float[](
	0.350f, 0.518f, 0.962f, 1.550f,
	1.094f, 1.506f, 1.962f,  1.962f
);


vec3 NEStoRGB(in int pixel, in int phase)
{
	int color = pixel & 0x0F;
	int level = (pixel >> 4) & 0x03;
	int emp = (pixel >> 6);
	
	if(color > 13)
		level = 1;
	
	float low = levels[0 + level];
	float high = levels[0 + level];
	
	if(color == 0)
		low = high;
	else if(color > 12)
		high = low;
		
	vec3 yiq = vec3(0);
	for(int i = 0; i < 12; i++)
	{
		float signal = (((color + phase + i) % 12) < 6) ? high : low;
		signal = (signal - levels[1]) / (levels[7] - levels[1]);
				
		float value = signal * Brightness / 12f;
		yiq.r += value;
		value *= Saturation;
		yiq.g += value * cos((3.141592653/6) * (phase  + 3.9f + i));
		yiq.b += value * sin((3.141592653/6) * (phase  + 3.9f + i));
	}
	
	
	vec3 rgb = YIQtoRGB(yiq);
	return min(vec3(255f), vec3(255.95f) * pow(max(vec3(0), rgb), vec3(2.2 / Gamma))) / vec3(255f);
}

vec3 NEStoYIQ(in ivec2 color)
{
	float signals[12];
	int c = color.x & 0x0F;
	int l = (color.x >> 4) & 3;
	int e = (color.x >> 6);
	if(c > 13)
	{
		l = 1;
	}
	
	float low = levels[0 + l];
	float high = levels[4 + l];
	if(c == 0)
	{
		low = high;
	}
	else if(c > 12)
	{
		high = low;
	}
	
	int p = color.y * 8;
	
	for(int i = 0; i < 12; i++)
	{
		signals[i] = (((c + p + i) % 12) < 6) ? high : low;
		signals[i] = (signals[i] - black) / (white - black);
		signals[i] /= 12f;
	}
	
	vec3 yiq = vec3(0);
	for(int i = 0; i < 12; i++)
	{
		float phasedPi = (PPUPhase + i)/6f * 3.14159265;
		yiq += vec3(signals[i]) * vec3(1, cos(phasedPi), sin(phasedPi));
	}
	
	return vec3(0,color.y/255f,color.x/255f);
}

void main()
{
	vec4 pos = PixelShape + vec4(gl_InstanceID, Scanline, 0, 0);
	gl_Position = PMatrix * pos;
	PixelColor = NEStoRGB(NESColor.x, NESColor.y);
}