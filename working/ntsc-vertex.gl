#version 330
layout(location = 0) in ivec2 NESColor;
layout(location = 1) in vec4 PixelShape;

uniform mat4 PMatrix;
uniform mat3 YIQMatrix;

const mat3 NonFCCYIQMatrix = mat3(
	vec3(1,1,1),
	vec3(0.9563, -0.2721, -1.1070),
	vec3(0.6210, -0.6474, 1.7046)
);


uniform int Scanline;
uniform float PPUPhase;

uniform float Gamma;

flat out vec3 PixelColor;

vec3 YIQtoRGB(in vec3 YIQ)
{
	return NonFCCYIQMatrix * YIQ;
}

const float black = 0.518f;
const float white = 1.962f;
const float atten = 0.746f;
const float levels[8] = float[](
	0.350f, 0.518f, 0.962f, 1.550f,
	1.094f, 1.506f, 1.962f,  1.962f
);

vec3 NEStoYIQ(in ivec2 color)
{
	float signals[12];
	int c = color.x & 0x0F;
	int l = (color.x >> 4) & 3;
	int e = (color.x >> 6);
	if(c > 13)
	{
		l = 1;
	}
	
	float low = levels[0 + l];
	float high = levels[4 + l];
	if(c == 0)
	{
		low = high;
	}
	else if(c > 12)
	{
		high = low;
	}
	
	int p = color.y;
	
	for(int i = 0; i < 12; i++)
	{
		signals[i] = (((c + p + i) % 12) < 6) ? high : low;
		signals[i] = (signals[i] - black) / (white - black);
		signals[i] /= 12f;
	}
	
	vec3 yiq = vec3(0);
	for(int i = 0; i < 12; i++)
	{
		float phasedPi = (PPUPhase + i)/6f * 3.14159265;
		yiq += vec3(signals[i]) * vec3(1, cos(phasedPi), sin(phasedPi));
	}
	
	return yiq;
}

void main()
{
	vec4 pos = PixelShape + vec4(gl_InstanceID, Scanline, 0, 0);
	gl_Position = PMatrix * pos;
	PixelColor = vec3(gl_InstanceID / 256f);
}